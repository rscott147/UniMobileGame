<!DOCTYPE html>
<html>
<head>
<title>Page Title</title>

<style>
	#menuContainer
	{
		position: absolute;
		width: 520;
		height: 440;
	}
	
	.button
	{
		background: url(button.png) no-repeat;
	}
	
	#menuContainer #playButton
	{
	  position: absolute;
	  top: 46%;
	  left: 50%;
	  transform: translate(-50%, -50%);
	  -ms-transform: translate(-50%, -50%);
	  background-color: #555;
	  color: white;
	  font-size: 16px;
	  padding: 12px 24px;
	  border: none;
	  cursor: pointer;
	  border-radius: 5px;
	  text-align: center;
	background: url(button.png) no-repeat;
	background-size: cover;
	background-position: center;
	width: 28%;
	height: 8%;
	}
	#menuContainer #tutorialButton
	{
	  position: absolute;
	  top: 58%;
	  left: 50%;
	  transform: translate(-50%, -50%);
	  -ms-transform: translate(-50%, -50%);
	  background-color: #555;
	  color: white;
	  font-size: 16px;
	  padding: 12px 24px;
	  border: none;
	  cursor: pointer;
	  border-radius: 5px;
	  text-align: center;
	background: url(button.png) no-repeat;
	background-size: cover;
	background-position: center;
	width: 28%;
	height: 8%;
	}
	#menuContainer #exitButton
	{
	  position: absolute;
	  top: 70%;
	  left: 50%;
	  transform: translate(-50%, -50%);
	  -ms-transform: translate(-50%, -50%);
	  background-color: #555;
	  color: white;
	  font-size: 16px;
	  padding: 12px 24px;
	  border: none;
	  cursor: pointer;
	  border-radius: 5px;
	  text-align: center;
	background: url(button.png) no-repeat;
	background-size: cover;
	background-position: center;
	width: 28%;
	height: 8%;
	}

    #menuContainer #tutMainMenu
	{
	  position: absolute;
	  top: 75%;
	  left: 50%;
	  transform: translate(-50%, -50%);
	  -ms-transform: translate(-50%, -50%);
	  background-color: #555;
	  color: white;
	  font-size: 12px;
	  padding: 6px 12px;
	  border: none;
	  cursor: pointer;
	  border-radius: 5px;
	  text-align: center;
	background: url(button.png) no-repeat;
	background-size: cover;
	background-position: center;
	width: 22%;
	height: 6%;
	}

    #menuContainer #tutNext
	{
	  position: absolute;
	  top: 75%;
	  left: 75%;
	  transform: translate(-50%, -50%);
	  -ms-transform: translate(-50%, -50%);
	  background-color: #555;
	  color: white;
	  font-size: 12px;
	  padding: 6px 12px;
	  border: none;
	  cursor: pointer;
	  border-radius: 5px;
	  text-align: center;
	background: url(NextButton.png) no-repeat;
	background-size: cover;
	background-position: center;
	width: 10%;
	height: 10%;
	}

    #menuContainer #tutPrev
	{
	  position: absolute;
	  top: 75%;
	  left: 25%;
	  transform: translate(-50%, -50%);
	  -ms-transform: translate(-50%, -50%);
	  background-color: #555;
	  color: white;
	  font-size: 12px;
	  padding: 6px 12px;
	  border: none;
	  cursor: pointer;
	  border-radius: 5px;
	  text-align: center;
	background: url(BackButton.png) no-repeat;
	background-size: cover;
	background-position: center;
	width: 10%;
	height: 10%;
	}


	#menuContainer #scoreDisplay
	{
	  position: absolute;
	  top: 55%;
	  left: 50%;
	  transform: translate(-50%, -50%);
	  -ms-transform: translate(-50%, -50%);
	  color: black;
	  font-size: 16px;
	  padding: 12px 24px;
	  border: none;
	  cursor: pointer;
	  border-radius: 5px;
	  text-align: center;
	}

	#menuContainer #playAgainButton
	{
	  position: absolute;
	  top: 75%;
	  left: 35%;
	  transform: translate(-50%, -50%);
	  -ms-transform: translate(-50%, -50%);
	  background-color: #555;
	  color: white;
	  font-size: 12px;
	  padding: 6px 12px;
	  border: none;
	  cursor: pointer;
	  border-radius: 5px;
	  text-align: center;
	background: url(button.png) no-repeat;
	background-size: cover;
	background-position: center;
	width: 22%;
	height: 6%;
	}

	#menuContainer #returnToMainButton
	{
	  position: absolute;
	  top: 75%;
	  left: 65%;
	  transform: translate(-50%, -50%);
	  -ms-transform: translate(-50%, -50%);
	  background-color: #555;
	  color: white;
	  font-size: 12px;
	  padding: 6px 12px;
	  border: none;
	  cursor: pointer;
	  border-radius: 5px;
	  text-align: center;
	background: url(button.png) no-repeat;
	background-size: cover;
	background-position: center;
	width: 22%;
	height: 6%;
	}

</style>
</head>
<body>
	<canvas id="canvasForTheGame"></canvas>
    <div id="menuContainer">
        <img id="background" src="MenuBackground.png">
        <button class="Button" id="playButton" onclick="Reset()" style="Display: initial;">Play</button>
        <button class="Button" id="tutorialButton" onclick="Tutorial()" style="Display: initial;">Tutorial</button>
        <button class="Button" id="exitButton" onclick="" style="Display: initial;">Exit</button>


        <button class="Button" id="tutMainMenu" onclick="ReturnMain()" style="Display: none;">Main Menu</button>
        <button class="Button" id="tutNext" onclick="NextTut()" style="Display: none;"></button>
        <button class="Button" id="tutPrev" onclick="PrevTut()" style="Display: none;"></button>

        <div id="scoreDisplay" style="Display: none;">
            You Scored
            <br>
            <p id="score">Score - 1000</p>
            <p id="highscore">Highscore - 1000</p>
        </div>
        <button class="Button" id="playAgainButton" onclick="Reset()" style="Display: none;">Play Again!</button>
        <button class="Button" id="returnToMainButton" onclick="ReturnMain()" style="Display: none;">Main Menu</button>
    </div>

	<script>
		//calls WebAPI for animaton loop, dependant on the browser being used.
		var requestAnimationFrame = window.requestAnimationFrame || 
									window.mozRequestAnimationFrame || 
									window.webkitRequestAnimationFrame || 
									window.msRequestAnimationFrame;
									
		window.requestAnimationFrame = requestAnimationFrame;
			
		var canvas = document.getElementById("canvasForTheGame");
		var width = 520;
		var height = 440;
		var ctx = canvas.getContext("2d");
		
		var keys = [];

		var gameState = "Main";

		var backgroundImg = document.getElementById("background");

		var playBtn = document.getElementById("playButton");
		var tutBtn = document.getElementById("tutorialButton");
		var exitBtn = document.getElementById("exitButton");

        var previousbtn = document.getElementById("tutPrev");
        var nextbtn = document.getElementById("tutNext");
        var tutMainbtn = document.getElementById("tutMainMenu");

		var scoreDisplay = document.getElementById("scoreDisplay");
		var playAgainBtn = document.getElementById("playAgainButton");
		var returnToMnBtn = document.getElementById("returnToMainButton");

		var mainMenuImg =  new Image();
        var gameOverImg = new Image();

        var controlImg = new Image();
        var HowtoplayImg1 = new Image();
        var HowtoplayImg2 = new Image();
        var tutpage = 0;

		//player variables
		var playerSprite = new Image();
		var imgBomb = new Image();
		var imgExplode = new Image();

		var score = 0;
		var highscore = 0;
		
		//tile variables
		var imgWall = new Image();
		var imgPath = new Image();

		var imgCrate = new Image();
		var imgRock = new Image();
		var imgGem = new Image();
        var imgGem2 = new Image();
        var imgGem2break = new Image();
        var imgGem3 = new Image();
        var imgGem3break = new Image();

		var imgLava = new Image();
		
		var obstacles = new Array();
		var bombs = new Array();
		var explosion = new Array();

		//image class
		class StaticImage
		{
			constructor(xpos, ypos, width, height)
			{
				this.m_xpos = xpos;
				this.m_ypos = ypos;
				this.m_width = width;
				this.m_height = height;
			}

			move(xpos)
			{
				this.m_xpos -= xpos;
			}

		}

		class Obstacle extends StaticImage
		{
			constructor(xpos, ypos, width, height, type)
			{
				super(xpos, ypos, width, height)
				this.m_type = type;
				this.m_durability = 1;

				this.m_exploded = false;

				if(this.m_type === 2)
				{
					this.m_points = 10;
					this.m_durability = 1;
				}
				else if(this.m_type === 3)
				{
					this.m_points = 50;
					this.m_durability = 2;
				}
				else if(this.m_type === 4)
				{
					this.m_points = 100;
					this.m_durability = 3;
				}
				else
				{
					this.m_points = 0;
				}
			}

			checkExplosive(list)
			{
				var m_list = list;

				if(this.m_exploded === false)
				{
					for(var i = 0; i< m_list.length; i++)
					{
						if(checkCollision(this, m_list[i]))
						{
							this.m_exploded = true;
							break;
						}
					}

					if(this.m_exploded)
					{
						this.m_durability--;
					}
				}
				else
				{
					for(var i = 0; i< m_list.length; i++)
					{
						if(!checkCollision(this, m_list[i]))
						{
							this.m_exploded = false;
							
						}
						else
						{
							this.m_exploded = true;
							break;
						}
					}
				}
			}

			draw()
			{
				if(this.m_type === 1)
				{
					ctx.drawImage(imgRock, this.m_xpos, this.m_ypos, this.m_width, this.m_height);
				}
				else if(this.m_type === 2)
				{
					ctx.drawImage(imgGem, this.m_xpos, this.m_ypos, this.m_width, this.m_height);
				}
				else if(this.m_type === 3)
                {
                    if (this.m_durability <= 1)
                    {
                        ctx.drawImage(imgGem2break, this.m_xpos, this.m_ypos, this.m_width, this.m_height);
                    }
                    else
                    {
                        ctx.drawImage(imgGem2, this.m_xpos, this.m_ypos, this.m_width, this.m_height);
                    }
				}
				else if(this.m_type === 4)
                {
                    if (this.m_durability <= 1)
                    {
                        ctx.drawImage(imgGem3break, this.m_xpos, this.m_ypos, this.m_width, this.m_height);
                    }
                    else
                    {
                        ctx.drawImage(imgGem3, this.m_xpos, this.m_ypos, this.m_width, this.m_height);
                    }
				}
			}
		}

		class TimedObject extends StaticImage
		{
			constructor(xpos, ypos, width, height, timer, maxTimer)
			{
				super(xpos, ypos, width, height)
				this.m_timer = timer;
				this.m_maxTime = maxTimer;

				this.m_explode = false;
			}

			Timer()
			{
				this.m_timer++;

				if(this.m_timer >= this.m_maxTime)
				{
					this.m_explode = true;
				}
			}

			drawBomb()
			{
				ctx.drawImage(imgBomb, this.m_xpos, this.m_ypos, this.m_width, this.m_height);
            }
        }

        class Explosion extends TimedObject
        {
            constructor(xpos, ypos, width, height, timer, maxTimer, xFrames, yFrames, maxFrame)
			{
				super(xpos, ypos, width, height, timer, maxTimer)

				this.m_startTime = 0;
				this.m_frameX = 0;
				this.m_frameXMax = xFrames;
				this.m_frameY = 0;
				this.m_frameYMax = yFrames;
				this.m_frame = 0;
				this.m_frameMax = maxFrame;

				this.m_frameTimer = timer;
				this.m_frameTimeMax = maxTimer;

				this.m_spriteWidth = 128;
				this.m_spriteHeight = 128;
				
            }

            Timer()
            {
                var m_elapsedTime = (Date.now() - this.m_startTime)/1000;
				this.m_startTime = Date.now();

				//only update frames when timer is below 0
				this.m_frameTimer = this.m_frameTimer - m_elapsedTime;
				if(this.m_frameTimer <= 0)
				{
					this.m_frameTimer = this.m_frameTimeMax;

						this.m_frameX++;

						if(this.m_frameX >= this.m_frameXMax)
						{
                            this.m_frameX = 0;
                            this.m_frameY++;
						}
						
					this.m_frame++;
					//reset frames to 0 in event that there are empty spaces on sprite sheet
					if(this.m_frame > this.m_frameMax)
					{
						this.m_explode = true;
					}
				}
				console.log(this.m_frame);
            }

            drawExplode()
			{
				ctx.drawImage(imgExplode, this.m_spriteWidth*this.m_frameX, this.m_spriteHeight*this.m_frameY, this.m_spriteWidth, this.m_spriteHeight, this.m_xpos, this.m_ypos, this.m_width, this.m_height);
			}
        }

		function bombManager(xpos, bomb, explode)
		{
			var m_bomb = bomb;
			var m_detonate = explode;

			for(var i = 0; i < m_bomb.length; i++)
			{
				m_bomb[i].move(xpos);
				m_bomb[i].Timer();

				//console.log(m_bomb[i]);

				if(m_bomb[i].m_explode)
				{
					generateExplosion(m_bomb[i], explode);
					m_bomb.splice(i, 1);				
				}			
			}

			for(var i = 0; i < m_detonate.length; i++)
			{
				m_detonate[i].move(xpos);
				m_detonate[i].Timer();

				if(m_detonate[i].m_explode)
				{
					m_detonate.splice(i, 1);
				}			
			}
		}

		function generateExplosion(bomb, list)
		{
			var m_bomb = bomb;
			var m_explosions = list;

			var topcheck = false;
			var botcheck = false;
			var leftcheck = false;
			var rightcheck = false;

			m_explosions.push(new Explosion(m_bomb.m_xpos, m_bomb.m_ypos, 40, 40, 0.5, 0.1, 4, 4, 14));

			for(var i = 0; i<2; i++)
			{
				if(topcheck === false)
				{
					var xcol = Math.floor((m_bomb.m_xpos  + (m_bomb.m_width/4))/map.tileWidth);
					var ycol = Math.floor((m_bomb.m_ypos + (m_bomb.m_width/4) - ((i+1)*40))/map.tileHeight);

					var tile = map.getTile(xcol, ycol);

					console.log(tile);

					switch(tile)
					{
					case 1:
						m_explosions.push(new Explosion(m_bomb.m_xpos, m_bomb.m_ypos  - ((i+1)*40), 40, 40, 0.5, 0.1, 4, 4, 14));
						break;
					default:
						topcheck = true;
						break;
					}
				}
				if(botcheck === false)
				{
					var xcol = Math.floor((m_bomb.m_xpos  + (m_bomb.m_width/4))/map.tileWidth);
					var ycol = Math.floor((m_bomb.m_ypos + (m_bomb.m_width/4) + ((i+1)*40))/map.tileHeight);

					var tile = map.getTile(xcol, ycol);

					switch(tile)
					{
					case 1:
						m_explosions.push(new Explosion(m_bomb.m_xpos, m_bomb.m_ypos  + ((i+1)*40), 40, 40, 0.5, 0.1, 4, 4, 14));
						break;
					default:
						botcheck = true;
						break;
					}
				}
				if (leftcheck === false)
				{
					var xcol = Math.floor((m_bomb.m_xpos + (m_bomb.m_width/4) - ((i+1)*40))/map.tileWidth);
					var ycol = Math.floor((m_bomb.m_ypos + (m_bomb.m_width/4))/map.tileHeight);



					var tile = map.getTile(xcol, ycol);

					switch(tile)
					{
					case 1:
						m_explosions.push(new Explosion(m_bomb.m_xpos   - ((i+1)*40), m_bomb.m_ypos, 40, 40, 0.5, 0.1, 4, 4, 14));
						break;
					default:
						leftcheck = true;
						break;
					}
				}
				if (rightcheck === false)
				{
					var xcol = Math.floor((m_bomb.m_xpos + (m_bomb.m_width/4) + ((i+1)*40))/map.tileWidth);
					var ycol = Math.floor((m_bomb.m_ypos + (m_bomb.m_width/4))/map.tileHeight);

					var tile = map.getTile(xcol, ycol);

					switch(tile)
					{
					case 1:
						m_explosions.push(new Explosion(m_bomb.m_xpos + ((i+1)*40), m_bomb.m_ypos, 40, 40, 0.5, 0.1, 4, 4, 14));
						break;
					default:
						rightcheck = true;
						break;
					}
				}
			}
		}

		function generateObstales(xpos, list)
		{
			var m_xpos = xpos;
			
			for(var j = 0; j<14; j++)
			{
				for(var i = 0; i<(map.mapHeight-2); i++)
				{
					//random number between 1 and 100
					var rng = Math.floor((Math.random() * 100) + 1);
					
					if(rng >= 40 && rng < 88)
					{
						var tile = map.getTile(m_xpos, i+1);
						switch(tile)
						{
							case 1:
								list.push(new Obstacle(m_xpos*40, (i+1)*40, 40, 40, 1))
								break;
							default:
								break;
						}
					}
					else if(rng >= 88 && rng < 94)
					{
						var tile = map.getTile(m_xpos, i+1);
						switch(tile)
						{
							case 1:
								list.push(new Obstacle(m_xpos*40, (i+1)*40, 40, 40, 2))
								break;
							default:
								break;
						}
					}
					else if(rng >= 94 && rng < 99)
					{
						var tile = map.getTile(m_xpos, i+1);
						switch(tile)
						{
							case 1:
								list.push(new Obstacle(m_xpos*40, (i+1)*40, 40, 40, 3))
								break;
							default:
								break;
						}
					}
					else if(rng >= 99)
					{
						var tile = map.getTile(m_xpos, i+1);
						switch(tile)
						{
							case 1:
								list.push(new Obstacle(m_xpos*40, (i+1)*40, 40, 40, 4))
								break;
							default:
								break;
						}
					}
				}
				m_xpos++
			}
		}

		//function for collision detection
		function checkCollision(obj1, obj2)
		{
			var object1 = obj1;
			var object2 = obj2;

			if((object1.m_xpos < object2.m_xpos + object2.m_width) &&
				(object1.m_xpos + object1.m_width > object2.m_xpos) &&
				(object1.m_ypos < object2.m_ypos  + object2.m_height) &&
				(object1.m_ypos + object1.m_height > object2.m_ypos))
				{
					return true;
				}
				else
				{
					return false
				}
		}
		//map variables
		var map = 
		{
			mapWidth: 27,
			mapHeight: 11,
			tileWidth: 40,
			tileHeight: 40,
			tileMap: [
			0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
			1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,
			1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
			1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,
			1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
			1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,
			1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
			1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,
			1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
			0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
			],

			getTile: function(x, y)
			{
				return this.tileMap[y * map.mapWidth + x]
			},

			/*isWalkable: function(x, y)
			{
				return this.tileMap[y + x]
				console.log(tileMap[y + x]);
			}*/
		};

		class lavaWall extends TimedObject
		{
			constructor(xpos, ypos, width, height, timer, maxTimer)
			{	
				super(xpos, ypos, width, height, timer, maxTimer)
			}

			moveWal(xpos)
			{
				this.m_timer++;

				if(this.m_timer >= this.m_maxTime)
				{
					this.m_xpos += map.tileWidth;
					this.m_timer = 0;
					this.moveTime--;
				}

				this.m_xpos -= xpos;
			}

			reset()
			{
				this.m_xpos = -width+40;
				this.m_ypos = map.tileHeight;
				this.m_width = width;
				this.m_height = height - 80;

				this.m_timer = 0;
			}

			drawWall()
			{
				ctx.drawImage(imgLava, this.m_xpos, this.m_ypos, this.m_width, this.m_height);
			}
		}

		var lava = new lavaWall(-width+40, map.tileHeight, width, height-80, 0, 300);

		var isKeyPressed = false;

		class Player extends StaticImage
		{
			constructor (xpos, ypos, width, height, speed, xFrames, yFrames, maxFrame)
			{
				super(xpos, ypos, width, height)

				this.m_VelX = 0;
				this.m_VelY = 0;

				this.m_speed = speed;
		
				this.m_startTime = 0;
				this.m_frameX = 0;
				this.m_frameXMax = xFrames;
				this.m_frameY = 0;
				this.m_frameYMax = yFrames;
				this.m_frame = 0;
				this.m_frameMax = maxFrame;

				this.m_frameTimer = 0.05;
				this.m_frameTimeMax = 0.1;
				
				//the size of the image rectangle on the sprite sheet (i think)
				this.m_spriteWidth = 24;
				this.m_spriteHeight = 32;

				this.bombDropped = false;
				this.playerCol = 
				{
					m_xpos: this.m_xpos +(6*40),
					m_ypos: this.m_ypos - 40,
					m_width: 10,
					m_height: 10,
				};
			}

			updatePlayer()
			{

				//Map looping
				if(this.m_xpos < 0)
				{
					this.m_xpos = 560;
				}
				else if(this.m_xpos > 560)
				{
					this.m_xpos = 0;
					generateObstales(13, obstacles);
				}

				//map collision variables for checking the current tile
				var xcol = Math.floor((this.m_xpos)/map.tileWidth);
				var ycol = Math.floor((this.m_ypos)/map.tileHeight);

				//Bomb dropping via the spacebar
				if (keys[32] && this.bombDropped === false) 
				{
					this.bombDropped = true;
					xcol = Math.floor((this.m_xpos+(this.m_width/2))/map.tileWidth);
					ycol = Math.floor((this.m_ypos+(this.m_height/2))/map.tileHeight);
				
					bombs.push(new TimedObject((xcol*40-this.m_xpos)+(6*40), ycol*40, 40, 40, 0, 240));			
				}
				else if(keys[32] === false && this.bombDropped)
				{
					this.bombDropped = false
				}


				if (keys[40]) 
				{
					this.m_frameY = 0;

					var colCheck = false;
					xcol = Math.floor((this.m_xpos+(this.m_width/2))/map.tileWidth);
					ycol = Math.floor((this.m_ypos+(this.m_height))/map.tileHeight);


					var direction = "down";
					this.updateCol(xcol, ycol, direction);

					for(var i = 0; i<obstacles.length; i++)
					{
						if(checkCollision(this.playerCol, obstacles[i]))
						{
							colCheck = true;
						}
					}

					if(!colCheck)
					{			
						// down arrow
						var tile = map.getTile(xcol,ycol);
						//console.log(tile);

						switch(tile)
						{
							case 1:
								this.m_VelY++;
								break;
							default:
								break;
						}
					}					
				}
				else if (keys[38]) 
				{
					this.m_frameY = 1;

					var colCheck = false;
					xcol = Math.floor((this.m_xpos+(this.m_width/2))/map.tileWidth);
					ycol = Math.floor((this.m_ypos)/map.tileHeight);

					var direction = "up";
					this.updateCol(xcol, ycol, direction);

					for(var i = 0; i<obstacles.length; i++)
					{
						if(checkCollision(this.playerCol, obstacles[i]))
						{
							colCheck = true;
						}
					}

					if(!colCheck)
					{
						// top arrow
					

						var tile = map.getTile(xcol,ycol);
						//console.log(tile);

						switch(tile)
						{
							case 1:
								this.m_VelY--;
								break;
							default:
								break;
						}
					}
				}
				else if (keys[39]) 
				{
					this.m_frameY = 3;
					var colCheck = false;
					xcol = Math.floor(((this.m_xpos+(this.m_width))/map.tileWidth));
					ycol = Math.floor((this.m_ypos+(this.m_height/2))/map.tileHeight);

					var direction = "right";
					this.updateCol(xcol, ycol, direction);

					for(var i = 0; i<obstacles.length; i++)
					{
						if(checkCollision(this.playerCol, obstacles[i]))
						{
							colCheck = true;
						}
					}

					if(!colCheck)
					{
						//right arrow
					

						if(xcol < 0)
							xcol = 0;

						var tile = map.getTile(xcol,ycol);
						//console.log(tile);

						switch(tile)
						{
							case 1:
								this.m_VelX++;
								break;
							default:
								break;
						}
					}
				}
				else if (keys[37]) 
				{
					this.m_frameY = 2;
					var colCheck = false;
					xcol = Math.floor(((this.m_xpos)/map.tileWidth));
					ycol = Math.floor((this.m_ypos+(this.m_height/2))/map.tileHeight);

					var direction = "left";
					this.updateCol(xcol, ycol, direction);

					for(var i = 0; i<obstacles.length; i++)
					{
						if(checkCollision(this.playerCol, obstacles[i]))
						{
							colCheck = true;
						}
					}

					if(!colCheck)
					{
						//left arrow
						xcol = Math.floor(((this.m_xpos)/map.tileWidth));
						ycol = Math.floor((this.m_ypos+(this.m_height/2))/map.tileHeight);
						//console.log(xcol);

						if(xcol < 0)
							xcol = 0;

						var tile = map.getTile(xcol,ycol);
						//console.log(tile);

						switch(tile)
						{
							case 1:
								this.m_VelX--;
								break;
							default:
								break;
						}
					}
				}
			
				this.m_VelX *= this.m_speed;
				this.m_VelY *= this.m_speed;
				this.m_xpos += this.m_VelX;
				this.m_ypos += this.m_VelY;
			}

			updateCol(colx, coly, direction)
			{
				var xcol = colx;
				var ycol = coly;
				var dir = direction;

				if(dir === "up")
				{
					this.playerCol.m_xpos = xcol + (6*40);
					this.playerCol.m_ypos = ycol*40;
				}
				if(dir === "down")
				{
					this.playerCol.m_xpos = xcol + (6*40);
					this.playerCol.m_ypos = ycol*40;
				}
				if(dir === "left")
				{
					this.playerCol.m_xpos = (xcol + (6*40))-15;
					this.playerCol.m_ypos = ycol*40;
				}
				if(dir === "right")
				{
					this.playerCol.m_xpos = (xcol + (6*40))+10;
					this.playerCol.m_ypos = ycol*40;
				}
			}

			reset()
			{
				this.m_xpos = 0;
				this.m_ypos = map.tileHeight*5;

				this.velX = 0;
				this.velY = 0;
			}

			drawPlayer()
			{
				var m_elapsedTime = (Date.now() - this.m_startTime)/1000;
				this.m_startTime = Date.now();

				//only update frames when timer is below 0
				this.m_frameTimer = this.m_frameTimer - m_elapsedTime;
				if(this.m_frameTimer <= 0)
				{
					this.m_frameTimer = this.m_frameTimeMax;

						this.m_frameX++;

						if(this.m_frameX >= this.m_frameXMax)
						{
							this.m_frameX = 0;
						}
						
					this.m_frame++;
					//reset frames to 0 in event that there are empty spaces on sprite sheet
					if(this.m_frame > this.m_frameMax)
					{
					  this.m_frame = 0;
					  this.m_frameX = 0;
					}
				}

				ctx.drawImage(playerSprite, this.m_spriteWidth*this.m_frameX, this.m_spriteHeight*this.m_frameY, this.m_spriteWidth, this.m_spriteHeight, (width/2) - (this.m_width/2), this.m_ypos, this.m_width, this.m_height);
			}
		}

		var player = new Player(0, map.tileHeight*5, 30, 30, 0.65, 8, 4, 8);

		function Reset()
		{
			score = 0;
			
			playBtn.style.display = "none";
			tutBtn.style.display = "none";
			exitBtn.style.display = "none";

			canvas.style.display = "initial";
			backgroundImg.style.display = "none";

			scoreDisplay.style.display = "none";
			playAgainBtn.style.display = "none";
			returnToMnBtn.style.display = "none";

			gameState = "Game";
			//empties bomb, explosion and obstacle arrays and regenerates the obstacles
			for(var i = 0; i< bombs.length; i++)
			{
				bombs.splice(i,1);
				i--;
			}
			for(var i = 0; i<explosion.length; i++)
			{
				explosion.splice(i,1);
				i--;
			}
			for(var i = 0; i<obstacles.length; i++)
			{
				obstacles.splice(i,1);
				i--;
			}

			player.reset();
			lava.reset();
			generateObstales(13, obstacles);
        }

        function Tutorial()
        {
            tutpage = 0;

            gameState = "Tutorial";

            playBtn.style.display = "none";
			tutBtn.style.display = "none";
            exitBtn.style.display = "none";

            previousbtn.style.display = "initial";
            nextbtn.style.display = "initial";
            tutMainbtn.style.display = "initial";
        }

        function NextTut()
        {
            tutpage++;

            if (tutpage > 2)
            {
                tutpage = 0;
            }
        }
        function PrevTut()
        {
            tutpage--;

            if (tutpage < 0)
            {
                tutpage = 2;
            }
        }

		function ReturnMain()
		{
			gameState = "Main";

			backgroundImg.style.display = "initial";
			backgroundImg.src = mainMenuImg.src;

			scoreDisplay.style.display = "none";
			playAgainBtn.style.display = "none";
            returnToMnBtn.style.display = "none";

            previousbtn.style.display = "none";
            nextbtn.style.display = "none";
            tutMainbtn.style.display = "none";

			playBtn.style.display = "initial";
			tutBtn.style.display = "initial";
			exitBtn.style.display = "initial";
		}

		function GameOver()
		{
			gameState = "GameOver";

			canvas.style.display = "none";

			backgroundImg.style.display = "initial";
			backgroundImg.src = gameOverImg.src;

			document.getElementById("score").innerHTML = "Score - " + score;

			if(score > highscore)
			{
				localStorage.setItem(highscore, score);
				highscore = localStorage.getItem(highscore);
			}

			if(highscore != null)
			document.getElementById("highscore").innerHTML = "Highscore - " + highscore;
			else
			document.getElementById("highscore").innerHTML = "Highscore - 0";

			scoreDisplay.style.display = "initial";
			playAgainBtn.style.display = "initial";
			returnToMnBtn.style.display = "initial";
		}

		//creates new function on load that runs the update function?
		window.addEventListener("load", function () 
		{
			start();
			update();
		});

		function start()
		{
			canvas.width = width;
			canvas.height = height;

			canvas.style.display = "none";
			
			mainMenuImg.src = "MenuBackground.png";
            gameOverImg.src = "GameOverBackground.png";

            controlImg.src = "TutControls.png";
            HowtoplayImg1.src = "TutHow1.png";
            HowtoplayImg2.src = "TutHow2.png";
            

			backgroundImg.src = mainMenuImg.src;

			playerSprite.src = 'Player.png';
			imgBomb.src = 'Bomb.png';
			imgExplode.src = 'Explosion.png';
			
			
			imgWall.src = 'Wall.png';
			imgPath.src = 'Dirt.png';
			imgRock.src = 'Rock.png';
			imgGem.src = 'Gem.png';
            imgGem2.src = 'Gem2.png';
            imgGem2break.src = "Gem2break.png";
            imgGem3.src = 'Gem3.png';
            imgGem3break.src = "Gem3break.png";

			imgLava.src = 'Lava.png';
			highscore = localStorage.getItem(highscore);

			generateObstales(13, obstacles);
		}
		
		
		function update() 
		{
			if(gameState === "Main")
			{
				//ctx.clearRect(0, 0, width, height);

				//ctx.drawImage(mainMenuImg,0,0,width,height);
            }
            else if(gameState === "Tutorial")
            {
                if (tutpage === 0)
                {
                    backgroundImg.src = controlImg.src;
                }
                else if (tutpage === 1)
                {
                    backgroundImg.src = HowtoplayImg1.src;
                }
                else if (tutpage === 2)
                {
                    backgroundImg.src = HowtoplayImg2.src;
                }
			}
			else if(gameState === "Game")
			{
				player.updatePlayer();

				for(var i = 0; i<explosion.length; i++)
				{
					if(checkCollision(player.playerCol, explosion[i]))
					{
						GameOver();
					}

					for(var j = 0; j<bombs.length; j++)
					{
						if(checkCollision(bombs[j], explosion[i]))
						{
							bombs[j].m_explode = true;
						}
					}
				}

				if(checkCollision(player.playerCol, lava))
				{
					GameOver();
				}

				bombManager(player.m_VelX, bombs, explosion);

				for(var i = 0; i<obstacles.length; i++)
				{
					obstacles[i].checkExplosive(explosion);
					if(obstacles[i].m_durability <= 0)
					{
						score += obstacles[i].m_points;
						obstacles.splice(i,1);
						i--;
					}
					else if(checkCollision(obstacles[i], lava))
					{
						obstacles.splice(i,1);
						i--;
					}
					else
					{
						obstacles[i].move(player.m_VelX);	
					}
				}
			
				ctx.clearRect(0, 0, width, height);
			
				//for loop to draw each tile
				for(var x = 0; x< map.mapWidth; x++)
				{
					for(var y = 0; y< map.mapHeight; y++)
					{
						var tile = map.getTile(x,y);
						//console.log(tile);
						switch(tile)
						{
							case 0:
								ctx.drawImage(imgWall, -(player.m_xpos) + (x*map.tileWidth), y*map.tileHeight, map.tileWidth, map.tileHeight);
								break;
							default:
								ctx.drawImage(imgPath, -(player.m_xpos) + (x*map.tileWidth), y*map.tileHeight, map.tileWidth, map.tileHeight);
								break;
						}
					}
				}
			
			

				//lavaWall
				lava.moveWal(player.m_VelX);
				lava.drawWall();

				//draw obstacles
			
				for(var i = 0; i<obstacles.length; i++)
				{
					obstacles[i].draw();
				}
			
				for(var i = 0; i<bombs.length; i++)
				{
					bombs[i].drawBomb();
				}

				for(var i = 0; i<explosion.length; i++)
				{
					explosion[i].drawExplode();
				}


				player.drawPlayer();

				ctx.fillRect(player.playerCol.m_xpos, player.playerCol.m_ypos, player.playerCol.m_width, player.playerCol.m_height);

				ctx.font = "16px Comic Sans MS";
				ctx.fillStyle = "black";
				ctx.textAlign = "left";
				ctx.fillText("Score - " + score, 10, height-16);

				ctx.textAlign = "right";


				if(highscore == null)
				{
					ctx.fillText("Highscore - 0", width - 10, height-16);
				}
				else
				{
					ctx.fillText("Highscore - " + highscore, width - 10, height-16);
				}
			}
			else if(gameState = "GameOver")
			{
				//ctx.clearRect(0, 0, width, height);
				//ctx.drawImage(gameOverImg,0,0,width,height);
			}

			requestAnimationFrame(update);
		}
		
		document.body.addEventListener("keydown", function (e) 
		{
			keys[e.keyCode] = true;
			isKeyPressed = true;
		});

		document.body.addEventListener("keyup", function (e) 
		{
			keys[e.keyCode] = false;
			isKeyPressed = false;
		});


	</script>
	
</body>
</html>
