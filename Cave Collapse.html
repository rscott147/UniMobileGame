<!DOCTYPE html>
<html>
<head>
<title>Page Title</title>
</head>
<body>
	<canvas id="canvasForTheGame"></canvas>
	<script>
		//calls WebAPI for animaton loop, dependant on the browser being used.
		var requestAnimationFrame = window.requestAnimationFrame || 
									window.mozRequestAnimationFrame || 
									window.webkitRequestAnimationFrame || 
									window.msRequestAnimationFrame;
									
		window.requestAnimationFrame = requestAnimationFrame;
			
		var canvas = document.getElementById("canvasForTheGame");
		var width = 520;
		var height = 440;
		var ctx = canvas.getContext("2d");
		
		var player = 
		{
			x: width / 2,
			y: height - 15,
			width: 40,
			height: 40,
			velX: 0,
			velY: 0
		};
		var keys = [];
		var friction = 0.8;
		
		var startTimeMS = 0;
		var frameX = 0;
		var frameXMax = 6;
		var frameY = 0;
		var frameYMax = 3;
		var frame = 0;
		var frameMax = 26;
		var frameTimer = 0.05;
		var frameTimeMax = 0.017;	
		var spriteWidth = 74;
		var spriteHeight = 86;
		var img = new Image();
		
		var imgWall = new Image();
		var imgPath = new Image();
		var tileWidth = 40;
		var tileHeight = 40;
		
		var mapWidth = 25
		var mapHeight = 11;
		var tileMap = [
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
		1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,
		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
		1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,
		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
		1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,
		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
		1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,
		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
		];
		
		var isKeyPressed = false;
		var flipped = false;


		//creates new function on load that runs the update function?
		window.addEventListener("load", function () {
			start();
			update();
		});

		function start()
		{
			canvas.width = width;
			canvas.height = height;
			
			img.src = 'braidSpriteSheet.png';
			
			imgWall.src = 'Wall.png';
			imgPath.src = 'Dirt.png';

			player.x = 0/*-(player.width/2)*/;
			player.y = (height/2)/*-(player.width/2)*/;
		}
		
		
		function update() 
		{
		
			if(player.x < 0)
			{
				player.x = 480;
			}
			else if(player.x > 480)
			{
				player.x = 0;
			}
			console.log(player.x);
			
			if (keys[40]) 
			{
				// top arrow
				if(player.y<(canvas.height-player.height-20))
					player.velY++;
					
			}
			if (keys[38]) 
			{
				// down arrow
				if(player.y>40)
					player.velY--;
					
			}
			if (keys[39]) 
			{
				// right arrow
				//if(player.x<(canvas.width-player.width-20))
					player.velX++;
					
				flipped = false;
			}
			if (keys[37]) 
			{
				// left arrow
				//if(player.x>player.width)
					
					player.velX--;
					
				flipped = true;
			}


			player.velX *= friction;
			player.velY *= friction;
			player.x += player.velX;
			player.y += player.velY;

			
			ctx.clearRect(0, 0, width, height);
			
			for(var y = 0; y< mapHeight; y++)
			{
				for(var x = 0; x<mapWidth; x++)
				{
					switch(tileMap[((y*mapWidth)+x)])
					{
						case 0:
							ctx.drawImage(imgWall, -(player.x)+ (x*tileWidth), y*tileHeight, tileWidth, tileHeight);
							break;
						default:
							ctx.drawImage(imgPath, -(player.x)+ (x*tileWidth), y*tileHeight, tileWidth, tileHeight);
							break;
					}
				}
			
			}
			
			if(flipped)
			{
				if(isKeyPressed)
				{
					animationFrame();
				
					ctx.scale(-1,1);
					ctx.drawImage(img, spriteWidth*frameX, spriteHeight*frameY, spriteWidth, spriteHeight, -(width/2) - (player.width/2), player.y, player.width, player.height);	
					ctx.scale(-1,1);
					console.log(flipped);
						
				} 
				else
				{
					ctx.scale(-1,1);
					ctx.drawImage(img, spriteWidth*6, spriteHeight*2, spriteWidth, spriteHeight, -(width/2) - (player.width/2), player.y, player.width, player.height);
					ctx.scale(-1,1);
				}
			}
			else
			{
				if(isKeyPressed)
				{
					animationFrame();
				
					ctx.drawImage(img, spriteWidth*frameX, spriteHeight*frameY, spriteWidth, spriteHeight, (width/2)-(player.width/2), player.y, player.width, player.height);	
					console.log(flipped);
						
				} 
				else
				{
					ctx.drawImage(img, spriteWidth*6, spriteHeight*2, spriteWidth, spriteHeight, (width/2)-(player.width/2), player.y, player.width, player.height);
				}
			}

			requestAnimationFrame(update);
		}
		
		function animationFrame()
		{
			var elapsed = (Date.now() - startTimeMS)/1000;
			startTimeMS = Date.now();

			//only update frames when timer is below 0
			frameTimer = frameTimer - elapsed;
			if(frameTimer <= 0)
			{
				frameTimer = frameTimeMax;
				
				
					frameX++;
					if(frameX>frameXMax)
					{
					  frameX = 0;
					  frameY++;
					  //end of row, move down to next row in sheet
					  if(frameY>frameYMax)
					  {
						  frameY = 0;
					  }
					}
					frame++;
					//reset frames to 0 in event that there are empty spaces on sprite sheet
					if(frame > frameMax)
					{
					  frame = 0;
					  frameX = 0;
					  frameY = 0;
					}
				
			}
		
		}
		
		function colCheck(shapeA, shapeB) 
		{
			// get the vectors to check against
			var vX = (shapeA.x + (shapeA.width / 2)) - (shapeB.x + (shapeB.width / 2)),
				vY = (shapeA.y + (shapeA.height / 2)) - (shapeB.y + (shapeB.height / 2)),
				// add the half widths and half heights of the objects
				hWidths = (shapeA.width / 2) + (shapeB.width / 2),
				hHeights = (shapeA.height / 2) + (shapeB.height / 2),
				colDir = null;

			// if the x and y vector are less than the half width or half height, they we must be inside the object, causing a collision
			if (Math.abs(vX) < hWidths && Math.abs(vY) < hHeights) 
			{
				// figures out on which side we are colliding (top, bottom, left, or right)
				var oX = hWidths - Math.abs(vX),
					oY = hHeights - Math.abs(vY);
				if (oX >= oY) 
				{
					if (vY > 0) 
					{
						colDir = "t";
						shapeA.y += oY;
					} 
					else 
					{
						colDir = "b";
						shapeA.y -= oY;
					}
				} 
				else 
				{
					if (vX > 0) 
					{
						colDir = "l";
						shapeA.x += oX;
					} 
					else 
					{
						colDir = "r";
						shapeA.x -= oX;
					}
				}
			}
			return colDir;
		}

		
		document.body.addEventListener("keydown", function (e) 
		{
			keys[e.keyCode] = true;
			isKeyPressed = true;
		});

		document.body.addEventListener("keyup", function (e) 
		{
			keys[e.keyCode] = false;
			isKeyPressed = false;
		});


	</script>
	
</body>
</html>
