<!DOCTYPE html>
<html>
<head>
<title>Page Title</title>
</head>
<body>
	<canvas id="canvasForTheGame"></canvas>
	<script>
		//calls WebAPI for animaton loop, dependant on the browser being used.
		var requestAnimationFrame = window.requestAnimationFrame || 
									window.mozRequestAnimationFrame || 
									window.webkitRequestAnimationFrame || 
									window.msRequestAnimationFrame;
									
		window.requestAnimationFrame = requestAnimationFrame;
			
		var canvas = document.getElementById("canvasForTheGame");
		var width = 520;
		var height = 440;
		var ctx = canvas.getContext("2d");
		
		var keys = [];
		var speed = 0.65;
		
		var startTimeMS = 0;
		var frameX = 0;
		var frameXMax = 6;
		var frameY = 0;
		var frameYMax = 3;
		var frame = 0;
		var frameMax = 26;
		var frameTimer = 0.05;
		var frameTimeMax = 0.017;	
		var spriteWidth = 74;
		var spriteHeight = 86;

		//player variables
		var playerSprite = new Image();
		var imgBomb = new Image();
		var imgExplode = new Image();
		
		//tile variables
		var imgWall = new Image();
		var imgPath = new Image();

		var imgCrate = new Image();
		var imgRock = new Image();
		var imgGem = new Image();
		var imgGem2 = new Image();
		var imgGem3 = new Image();

		var imgLava = new Image();
		
		var obstacles = new Array();
		var bombs = new Array();
		var explosion = new Array();

		//image class
		class StaticImage
		{
			constructor(xpos, ypos, width, height)
			{
				this.m_xpos = xpos;
				this.m_ypos = ypos;
				this.m_width = width;
				this.m_height = height;
			}

			move(xpos)
			{
				this.m_xpos -= xpos;
			}

		}

		class Obstacle extends StaticImage
		{
			constructor(xpos, ypos, width, height, type)
			{
				super(xpos, ypos, width, height)
				this.m_type = type;
			}

			checkExplosive(list)
			{
				var m_list = list;

				for(var i = 0; i< m_list.length; i++)
				{
					if(checkCollision(this, m_list[i]))
					{
						return true;
					}
				}
			}

			draw()
			{
				if(this.m_type === 1)
				{
					ctx.drawImage(imgCrate, this.m_xpos, this.m_ypos, this.m_width, this.m_height);
				}
				else if(this.m_type === 2)
				{
					ctx.drawImage(imgGem, this.m_xpos, this.m_ypos, this.m_width, this.m_height);
				}
				else if(this.m_type === 3)
				{
					ctx.drawImage(imgGem2, this.m_xpos, this.m_ypos, this.m_width, this.m_height);
				}
				else if(this.m_type === 4)
				{
					ctx.drawImage(imgGem3, this.m_xpos, this.m_ypos, this.m_width, this.m_height);
				}
			}
		}

		class TimedObject extends StaticImage
		{
			constructor(xpos, ypos, width, height, timer, maxTimer)
			{
				super(xpos, ypos, width, height)
				this.m_timer = timer;
				this.m_maxTime = maxTimer;

				this.m_xplode = false;
			}

			Timer()
			{
				this.m_timer++;

				if(this.m_timer >= this.m_maxTime)
				{
					this.m_explode = true;
				}
			}

			drawBomb()
			{
				ctx.drawImage(imgBomb, this.m_xpos, this.m_ypos, this.m_width, this.m_height);
			}

			drawExplode()
			{
				ctx.drawImage(imgExplode, this.m_xpos, this.m_ypos, this.m_width, this.m_height);
			}
		}

		function bombManager(xpos, bomb, explode)
		{
			var m_bomb = bomb;
			var m_detonate = explode;

			for(var i = 0; i < m_bomb.length; i++)
			{
				m_bomb[i].move(xpos);
				m_bomb[i].Timer();

				//console.log(m_bomb[i]);

				if(m_bomb[i].m_explode)
				{
					generateExplosion(m_bomb[i], explode);
					m_bomb.splice(i, 1);				
				}			
			}

			for(var i = 0; i < m_detonate.length; i++)
			{
				m_detonate[i].move(xpos);
				m_detonate[i].Timer();

				//console.log(m_bomb[i]);

				if(m_detonate[i].m_explode)
				{
					m_detonate.splice(i, 1);
				}			
			}
		}

		function generateExplosion(bomb, list)
		{
			var m_bomb = bomb;
			var m_explosions = list;

			var topcheck = false;
			var botcheck = false;
			var leftcheck = false;
			var rightcheck = false;

			m_explosions.push(new TimedObject(m_bomb.m_xpos, m_bomb.m_ypos, 40, 40, 0, 120));

			for(var i = 0; i<2; i++)
			{
				if(topcheck === false)
				{
					var xcol = Math.floor((m_bomb.m_xpos)/map.tileWidth);
					var ycol = Math.floor((m_bomb.m_ypos - ((i+1)*40))/map.tileHeight);

					console.log(xcol);
					console.log(ycol);

					var tile = map.getTile(xcol, ycol);

					console.log(tile);

					switch(tile)
					{
					case 1:
						m_explosions.push(new TimedObject(m_bomb.m_xpos, m_bomb.m_ypos - ((i+1)*40), 40, 40, 0, 120));
						break;
					default:
						topcheck = true;
						break;
					}
				}
				if(botcheck === false)
				{
					var xcol = Math.floor((m_bomb.m_xpos)/map.tileWidth);
					var ycol = Math.floor((m_bomb.m_ypos + ((i+1)*40))/map.tileHeight);

					var tile = map.getTile(xcol, ycol);

					switch(tile)
					{
					case 1:
						m_explosions.push(new TimedObject(m_bomb.m_xpos, m_bomb.m_ypos + ((i+1)*40), 40, 40, 0, 120));
						break;
					default:
						botcheck = true;
						break;
					}
				}
				if (leftcheck === false)
				{
					var xcol = Math.floor((m_bomb.m_xpos - ((i+1)*40) +player.velX)/map.tileWidth);
					var ycol = Math.floor((m_bomb.m_ypos)/map.tileHeight);

					var tile = map.getTile(xcol, ycol);

					switch(tile)
					{
					case 1:
						m_explosions.push(new TimedObject(m_bomb.m_xpos - ((i+1)*40), m_bomb.m_ypos, 40, 40, 0, 120));
						break;
					default:
						leftcheck = true;
						break;
					}
				}
				if (rightcheck === false)
				{
					var xcol = Math.floor((m_bomb.m_xpos + ((i+1)*40)+player.velX)/map.tileWidth);
					var ycol = Math.floor((m_bomb.m_ypos)/map.tileHeight);

					var tile = map.getTile(xcol, ycol);

					switch(tile)
					{
					case 1:
						m_explosions.push(new TimedObject(m_bomb.m_xpos + ((i+1)*40), m_bomb.m_ypos, 40, 40, 0, 120));
						break;
					default:
						rightcheck = true;
						break;
					}
				}
			}
		}

		function generateObstales(xpos, list)
		{
			var m_xpos = xpos;
			
			for(var j = 0; j<14; j++)
			{
				for(var i = 0; i<(map.mapHeight-2); i++)
				{
					//random number between 1 and 100
					var rng = Math.floor((Math.random() * 100) + 1);
					
					if(rng >= 40 && rng < 85)
					{
						var tile = map.getTile(m_xpos, i+1);
						switch(tile)
						{
							case 1:
								list.push(new Obstacle(m_xpos*40, (i+1)*40, 40, 40, 1))
								break;
							default:
								break;
						}
					}
					else if(rng >= 85 && rng < 92)
					{
						var tile = map.getTile(m_xpos, i+1);
						switch(tile)
						{
							case 1:
								list.push(new Obstacle(m_xpos*40, (i+1)*40, 40, 40, 2))
								break;
							default:
								break;
						}
					}
					else if(rng >= 92 && rng < 99)
					{
						var tile = map.getTile(m_xpos, i+1);
						switch(tile)
						{
							case 1:
								list.push(new Obstacle(m_xpos*40, (i+1)*40, 40, 40, 3))
								break;
							default:
								break;
						}
					}
					else if(rng >= 99)
					{
						var tile = map.getTile(m_xpos, i+1);
						switch(tile)
						{
							case 1:
								list.push(new Obstacle(m_xpos*40, (i+1)*40, 40, 40, 4))
								break;
							default:
								break;
						}
					}
				}
				m_xpos++
			}
		}

		function checkCollision(obj1, obj2)
		{
			var object1 = obj1;
			var object2 = obj2;

			if((object1.m_xpos < object2.m_xpos + object2.m_width) &&
				(object1.m_xpos + object1.m_width > object2.m_xpos) &&
				(object1.m_ypos < object2.m_ypos  + object2.m_height) &&
				(object1.m_ypos + object1.m_height > object2.m_ypos))
				{
					return true;
				}
				else
				{
					return false
				}
		}
		//map variables
		var map = 
		{
			mapWidth: 27,
			mapHeight: 11,
			tileWidth: 40,
			tileHeight: 40,
			tileMap: [
			0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
			1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,
			1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
			1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,
			1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
			1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,
			1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
			1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,
			1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
			0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
			],

			getTile: function(x, y)
			{
				return this.tileMap[y * map.mapWidth + x]
			},

			isWalkable: function(x, y)
			{
				return this.tileMap[y + x]
				console.log(tileMap[y + x]);
			}
		};

		class lavaWall extends TimedObject
		{
			constructor(xpos, ypos, width, height, timer, maxTimer)
			{	
				super(xpos, ypos, width, height, timer, maxTimer)
			}

			moveWal(xpos)
			{
				this.m_timer++;

				if(this.m_timer >= this.m_maxTime)
				{
					this.m_xpos += map.tileWidth;
					this.m_timer = 0;
					this.moveTime--;
				}

				this.m_xpos -= xpos;
			}

			drawWall()
			{
				ctx.drawImage(imgLava, this.m_xpos, this.m_ypos, this.m_width, this.m_height);
			}
		}

		var lava = new lavaWall(-width+40, map.tileHeight, width, height-80, 0, 300);

		var isKeyPressed = false;
		var flipped = false;

		var player = 
		{
			x: 0,
			y: map.tileHeight*6,
			width: 30,
			height: 30,
			velX: 0,
			velY: 0
		};

		//creates new function on load that runs the update function?
		window.addEventListener("load", function () 
		{
			start();
			update();
		});

		function start()
		{
			canvas.width = width;
			canvas.height = height;
			
			playerSprite.src = 'braidSpriteSheet.png';
			imgBomb.src = 'Bomb.png';
			imgExplode.src = 'Boom.png';
			
			
			imgWall.src = 'Wall.png';
			imgPath.src = 'Dirt.png';
			imgCrate.src = 'Crate.png';
			imgGem.src = 'Gem.png';
			imgGem2.src = 'Gem2.png';
			imgGem3.src = 'Gem3.png';

			imgLava.src = 'Lava.jpg';

			player.x = 0;
			player.y = map.tileWidth*5;

			generateObstales(13, obstacles);
		}
		
		
		function update() 
		{
		
			if(player.x < 0)
			{
				player.x = 560;
			}
			else if(player.x > 560)
			{
				player.x = 0;
				generateObstales(13, obstacles);
			}
			//console.log(player.x);

			var xcol = Math.floor((player.x)/map.tileWidth);
			var ycol = Math.floor((player.y)/map.tileHeight);
			//console.log(xcol);
			//console.log(ycol);
			
			if (keys[32]) 
			{
				xcol = Math.floor((player.x+(player.width/2))/map.tileWidth);
				ycol = Math.floor((player.y+(player.height/2))/map.tileHeight);
				
				bombs.push(new TimedObject((xcol*40-player.x)+(6*40), ycol*40, 40, 40, 0, 240));
				
			}
			
			if (keys[40]) 
			{
				xcol = Math.floor((player.x+(player.width/2))/map.tileWidth);
				ycol = Math.floor((player.y+(player.height))/map.tileHeight);
				// down arrow
				var tile = map.getTile(xcol,ycol);
				//console.log(tile);

				switch(tile)
				{
					case 1:
						player.velY++;
						break;
					default:
						break;
				}
					
			}
			else if (keys[38]) 
			{
				// top arrow
				xcol = Math.floor((player.x+(player.width/2))/map.tileWidth);
				ycol = Math.floor((player.y)/map.tileHeight);

				var tile = map.getTile(xcol,ycol);
				//console.log(tile);

				switch(tile)
				{
					case 1:
						player.velY--;
						break;
					default:
						break;
				}
					
			}
			else if (keys[39]) 
			{
				//right arrow
				xcol = Math.floor(((player.x+(player.width))/map.tileWidth));
				ycol = Math.floor((player.y+(player.height/2))/map.tileHeight);

				if(xcol < 0)
					xcol = 0;

				var tile = map.getTile(xcol,ycol);
				//console.log(tile);

				switch(tile)
				{
					case 1:
						player.velX++;
						break;
					default:
						break;
				}
					
				flipped = false;
			}
			else if (keys[37]) 
			{
			    //left arrow
				xcol = Math.floor(((player.x)/map.tileWidth));
				ycol = Math.floor((player.y+(player.height/2))/map.tileHeight);
				//console.log(xcol);

				if(xcol < 0)
					xcol = 0;

				var tile = map.getTile(xcol,ycol);
				//console.log(tile);

				switch(tile)
				{
					case 1:
						player.velX--;
						break;
					default:
						break;
				}
				flipped = true;
			}


			player.velX *= speed;
			player.velY *= speed;
			player.x += player.velX;
			player.y += player.velY;

			bombManager(player.velX, bombs, explosion);

			for(var i = 0; i<obstacles.length; i++)
			{
				if(obstacles[i].checkExplosive(explosion) || checkCollision(obstacles[i], lava))
				{
					obstacles.splice(i,1);
					i--;
				}
				else
				{
					obstacles[i].move(player.velX);	
				}
			}
			
			ctx.clearRect(0, 0, width, height);
			
			//for loop to draw each tile
			for(var x = 0; x< map.mapWidth; x++)
			{
				for(var y = 0; y< map.mapHeight; y++)
				{
					var tile = map.getTile(x,y);
					//console.log(tile);
					switch(tile)
					{
						case 0:
							ctx.drawImage(imgWall, -(player.x)+ (x*map.tileWidth), y*map.tileHeight, map.tileWidth, map.tileHeight);
							break;
						default:
							ctx.drawImage(imgPath, -(player.x)+ (x*map.tileWidth), y*map.tileHeight, map.tileWidth, map.tileHeight);
							break;
					}
				}
			}

			//lavaWall
			lava.drawWall();

			//draw obstacles
			
			for(var i = 0; i<obstacles.length; i++)
			{
				
				obstacles[i].draw();
				
			}
			

			for(var i = 0; i<bombs.length; i++)
			{
				bombs[i].drawBomb();
			}

			for(var i = 0; i<explosion.length; i++)
			{
				explosion[i].drawExplode();
			}

			//Player Sprite
			if(flipped)
			{
				if(isKeyPressed)
				{
					animationFrame();
				
					ctx.scale(-1,1);
					ctx.drawImage(playerSprite, spriteWidth*frameX, spriteHeight*frameY, spriteWidth, spriteHeight, -(width/2) - (player.width/2), player.y, player.width, player.height);	
					ctx.scale(-1,1);
					console.log(flipped);
						
				} 
				else
				{
					ctx.scale(-1,1);
					ctx.drawImage(playerSprite, spriteWidth*6, spriteHeight*2, spriteWidth, spriteHeight, -(width/2) - (player.width/2), player.y, player.width, player.height);
					ctx.scale(-1,1);
				}
			}
			else
			{
				if(isKeyPressed)
				{
					animationFrame();
				
					ctx.drawImage(playerSprite, spriteWidth*frameX, spriteHeight*frameY, spriteWidth, spriteHeight, (width/2)-(player.width/2), player.y, player.width, player.height);	
					console.log(flipped);
						
				} 
				else
				{
					ctx.drawImage(playerSprite, spriteWidth*6, spriteHeight*2, spriteWidth, spriteHeight, (width/2)-(player.width/2), player.y, player.width, player.height);
				}
			}

			//lavaWall
			lava.drawWall();

			//xcol = Math.floor((player.x)/map.tileWidth);
			//ycol = Math.floor((player.y)/map.tileHeight);
			//console.log(player.x);
			ctx.fillRect((xcol*40-player.x)+(6*40),ycol*40, 10, 10);

			requestAnimationFrame(update);
		}


		
		function animationFrame()
		{
			var elapsed = (Date.now() - startTimeMS)/1000;
			startTimeMS = Date.now();

			//only update frames when timer is below 0
			frameTimer = frameTimer - elapsed;
			if(frameTimer <= 0)
			{
				frameTimer = frameTimeMax;
				
				
					frameX++;
					if(frameX>frameXMax)
					{
					  frameX = 0;
					  frameY++;
					  //end of row, move down to next row in sheet
					  if(frameY>frameYMax)
					  {
						  frameY = 0;
					  }
					}
					frame++;
					//reset frames to 0 in event that there are empty spaces on sprite sheet
					if(frame > frameMax)
					{
					  frame = 0;
					  frameX = 0;
					  frameY = 0;
					}				
			}	
		}

		
		
		document.body.addEventListener("keydown", function (e) 
		{
			keys[e.keyCode] = true;
			isKeyPressed = true;
		});

		document.body.addEventListener("keyup", function (e) 
		{
			keys[e.keyCode] = false;
			isKeyPressed = false;
		});


	</script>
	
</body>
</html>
