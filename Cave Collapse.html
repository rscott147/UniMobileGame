<!DOCTYPE html>
<html>
<head>
<title>Page Title</title>

<style>
	#menuContainer
	{
		position: absolute;
		width: 520;
		height: 440;
	}
	
	.button
	{
		background: url(button.png) no-repeat;
	}
	
	#menuContainer #playButton
	{
	  position: absolute;
	  top: 46%;
	  left: 50%;
	  transform: translate(-50%, -50%);
	  -ms-transform: translate(-50%, -50%);
	  background-color: #555;
	  color: white;
	  font-size: 16px;
	  padding: 12px 24px;
	  border: none;
	  cursor: pointer;
	  border-radius: 5px;
	  text-align: center;
	background: url(button.png) no-repeat;
	background-size: cover;
	background-position: center;
	width: 28%;
	height: 8%;
	}
	#menuContainer #tutorialButton
	{
	  position: absolute;
	  top: 58%;
	  left: 50%;
	  transform: translate(-50%, -50%);
	  -ms-transform: translate(-50%, -50%);
	  background-color: #555;
	  color: white;
	  font-size: 16px;
	  padding: 12px 24px;
	  border: none;
	  cursor: pointer;
	  border-radius: 5px;
	  text-align: center;
	background: url(button.png) no-repeat;
	background-size: cover;
	background-position: center;
	width: 28%;
	height: 8%;
	}
	#menuContainer #exitButton
	{
	  position: absolute;
	  top: 70%;
	  left: 50%;
	  transform: translate(-50%, -50%);
	  -ms-transform: translate(-50%, -50%);
	  background-color: #555;
	  color: white;
	  font-size: 16px;
	  padding: 12px 24px;
	  border: none;
	  cursor: pointer;
	  border-radius: 5px;
	  text-align: center;
	background: url(button.png) no-repeat;
	background-size: cover;
	background-position: center;
	width: 28%;
	height: 8%;
	}

    #menuContainer #tutMainMenu
	{
	  position: absolute;
	  top: 75%;
	  left: 50%;
	  transform: translate(-50%, -50%);
	  -ms-transform: translate(-50%, -50%);
	  background-color: #555;
	  color: white;
	  font-size: 12px;
	  padding: 6px 12px;
	  border: none;
	  cursor: pointer;
	  border-radius: 5px;
	  text-align: center;
	background: url(button.png) no-repeat;
	background-size: cover;
	background-position: center;
	width: 22%;
	height: 6%;
	}

    #menuContainer #tutNext
	{
	  position: absolute;
	  top: 75%;
	  left: 75%;
	  transform: translate(-50%, -50%);
	  -ms-transform: translate(-50%, -50%);
	  background-color: #555;
	  color: white;
	  font-size: 12px;
	  padding: 6px 12px;
	  border: none;
	  cursor: pointer;
	  border-radius: 5px;
	  text-align: center;
	background: url(NextButton.png) no-repeat;
	background-size: cover;
	background-position: center;
	width: 10%;
	height: 10%;
	}

    #menuContainer #tutPrev
	{
	  position: absolute;
	  top: 75%;
	  left: 25%;
	  transform: translate(-50%, -50%);
	  -ms-transform: translate(-50%, -50%);
	  background-color: #555;
	  color: white;
	  font-size: 12px;
	  padding: 6px 12px;
	  border: none;
	  cursor: pointer;
	  border-radius: 5px;
	  text-align: center;
	background: url(BackButton.png) no-repeat;
	background-size: cover;
	background-position: center;
	width: 10%;
	height: 10%;
	}


	#menuContainer #scoreDisplay
	{
	  position: absolute;
	  top: 55%;
	  left: 50%;
	  transform: translate(-50%, -50%);
	  -ms-transform: translate(-50%, -50%);
	  color: black;
	  font-size: 16px;
	  padding: 12px 24px;
	  border: none;
	  cursor: pointer;
	  border-radius: 5px;
	  text-align: center;
	}

	#menuContainer #playAgainButton
	{
	  position: absolute;
	  top: 75%;
	  left: 35%;
	  transform: translate(-50%, -50%);
	  -ms-transform: translate(-50%, -50%);
	  background-color: #555;
	  color: white;
	  font-size: 12px;
	  padding: 6px 12px;
	  border: none;
	  cursor: pointer;
	  border-radius: 5px;
	  text-align: center;
	background: url(button.png) no-repeat;
	background-size: cover;
	background-position: center;
	width: 22%;
	height: 6%;
	}

	#menuContainer #returnToMainButton
	{
	  position: absolute;
	  top: 75%;
	  left: 65%;
	  transform: translate(-50%, -50%);
	  -ms-transform: translate(-50%, -50%);
	  background-color: #555;
	  color: white;
	  font-size: 12px;
	  padding: 6px 12px;
	  border: none;
	  cursor: pointer;
	  border-radius: 5px;
	  text-align: center;
	background: url(button.png) no-repeat;
	background-size: cover;
	background-position: center;
	width: 22%;
	height: 6%;
	}

</style>
</head>
<body>
	<canvas id="canvasForTheGame"></canvas>
    <div id="menuContainer">
        <img id="background" src="MenuBackground.png">
        <button class="Button" id="playButton" onclick="Reset()" style="Display: initial;">Play</button>
        <button class="Button" id="tutorialButton" onclick="Tutorial()" style="Display: initial;">Tutorial</button>
        <button class="Button" id="exitButton" onclick="" style="Display: initial;">Exit</button>


        <button class="Button" id="tutMainMenu" onclick="ReturnMain()" style="Display: none;">Main Menu</button>
        <button class="Button" id="tutNext" onclick="NextTut()" style="Display: none;"></button>
        <button class="Button" id="tutPrev" onclick="PrevTut()" style="Display: none;"></button>

        <div id="scoreDisplay" style="Display: none;">
            You Scored
            <br>
            <p id="score">Score - 1000</p>
            <p id="highscore">Highscore - 1000</p>
        </div>
        <button class="Button" id="playAgainButton" onclick="Reset()" style="Display: none;">Play Again!</button>
        <button class="Button" id="returnToMainButton" onclick="ReturnMain()" style="Display: none;">Main Menu</button>
    </div>
	<audio id = "music" src = "MenuMusic.wav" autoplay = "true"></audio>
	<audio id = "lavamove" src = "LavaMove.wav" autoplay = "true"></audio>
	<audio id = "bombaudio" src = "BombAudio.mp3" autoplay = "true"></audio>
	<script>
		//calls WebAPI for animaton loop, dependant on the browser being used.
		var requestAnimationFrame = window.requestAnimationFrame || 
									window.mozRequestAnimationFrame || 
									window.webkitRequestAnimationFrame || 
									window.msRequestAnimationFrame;
									
		window.requestAnimationFrame = requestAnimationFrame;
			
		var canvas = document.getElementById("canvasForTheGame");
		var width = 520;
		var height = 440;
		var ctx = canvas.getContext("2d");
		
		var keys = [];

		var gameState = "Main";

		var backgroundImg = document.getElementById("background");

		var playBtn = document.getElementById("playButton");
		var tutBtn = document.getElementById("tutorialButton");
		var exitBtn = document.getElementById("exitButton");

        var previousbtn = document.getElementById("tutPrev");
        var nextbtn = document.getElementById("tutNext");
        var tutMainbtn = document.getElementById("tutMainMenu");

		var scoreDisplay = document.getElementById("scoreDisplay");
		var playAgainBtn = document.getElementById("playAgainButton");
		var returnToMnBtn = document.getElementById("returnToMainButton");

		var mainMenuImg =  new Image();
        var gameOverImg = new Image();

        var controlImg = new Image();
        var HowtoplayImg1 = new Image();
        var HowtoplayImg2 = new Image();
        var tutpage = 0;

		//player variables
		var playerSprite = new Image();
		var imgBomb = new Image();
		var imgExplode = new Image();

		var score = 0;
		var highscore = 0;
		
		//tile variables
		var imgWall = new Image();
		var imgPath = new Image();

		var imgCrate = new Image();
		var imgRock = new Image();
		var imgGem = new Image();
        var imgGem2 = new Image();
        var imgGem2break = new Image();
        var imgGem3 = new Image();
        var imgGem3break = new Image();

		var imgLava = new Image();
		
		var obstacles = new Array();
		var bombs = new Array();
		var explosion = new Array();

		var music = document.getElementById("music");
		var lavaAudio = document.getElementById("lavamove");
		var bombAudio = document.getElementById("bombaudio");

		//image class
		class StaticImage
		{
			constructor(xpos, ypos, width, height)
			{
			//base variables to hold the objects position, width and height
				this.m_xpos = xpos;
				this.m_ypos = ypos;
				this.m_width = width;
				this.m_height = height;
			}

			//this method moves the object based on the negative of the inputed x position
			move(xpos)
			{
				this.m_xpos -= xpos;
			}

		}

		class Obstacle extends StaticImage
		{
			constructor(xpos, ypos, width, height, type)
			{
				super(xpos, ypos, width, height)
				this.m_type = type;
				this.m_durability = 1;

				this.m_exploded = false;

				//checks the inputed type and adjusts the amount of points given and the obstacles durability based on the type.
				if(this.m_type === 2)
				{
					this.m_points = 10;
					this.m_durability = 1;
				}
				else if(this.m_type === 3)
				{
					this.m_points = 50;
					this.m_durability = 2;
				}
				else if(this.m_type === 4)
				{
					this.m_points = 100;
					this.m_durability = 3;
				}
				else
				{
					this.m_points = 0;
				}
			}

			//this function checks to see if the obstacle has collided with any of the explosions
			checkExplosive(list)
			{
				var m_list = list;

				//checks to see if the obstacles "exploded" value is set to false
				if(this.m_exploded === false)
				{	//checks each item in the explosion list
					for(var i = 0; i< m_list.length; i++)
					{	
					//checks the collision of the obstacle and the currently selected explosion tile, it it returns as true then the m_exploded variable is set to true and the function then stops running the loop
						if(checkCollision(this, m_list[i]))
						{
							this.m_exploded = true;
							break;
						}
					}

					//lowers durability of this obstacle if an explosion has been collided with
					if(this.m_exploded)
					{
						this.m_durability--;
					}
				}
				else
				{
				//loops through each explosion and checks to see if the obstacle is still colliding with an explosion. If it is not, then its durability can be lowered by another explosion.
					for(var i = 0; i< m_list.length; i++)
					{
						if(!checkCollision(this, m_list[i]))
						{
							this.m_exploded = false;
							
						}
						else
						{
							this.m_exploded = true;
							break;
						}
					}
				}
			}

			//draws the obstacle using an image based on its type. For the obstacles that have higher durability, a cracked version of their image is drawn when their durability gets low.
			draw()
			{
				if(this.m_type === 1)
				{
					ctx.drawImage(imgRock, this.m_xpos, this.m_ypos, this.m_width, this.m_height);
				}
				else if(this.m_type === 2)
				{
					ctx.drawImage(imgGem, this.m_xpos, this.m_ypos, this.m_width, this.m_height);
				}
				else if(this.m_type === 3)
                {
                    if (this.m_durability <= 1)
                    {
                        ctx.drawImage(imgGem2break, this.m_xpos, this.m_ypos, this.m_width, this.m_height);
                    }
                    else
                    {
                        ctx.drawImage(imgGem2, this.m_xpos, this.m_ypos, this.m_width, this.m_height);
                    }
				}
				else if(this.m_type === 4)
                {
                    if (this.m_durability <= 1)
                    {
                        ctx.drawImage(imgGem3break, this.m_xpos, this.m_ypos, this.m_width, this.m_height);
                    }
                    else
                    {
                        ctx.drawImage(imgGem3, this.m_xpos, this.m_ypos, this.m_width, this.m_height);
                    }
				}
			}
		}

		class TimedObject extends StaticImage
		{
			constructor(xpos, ypos, width, height, timer, maxTimer)
			{
				super(xpos, ypos, width, height)
				this.m_timer = timer;
				this.m_maxTime = maxTimer;

				this.m_explode = false;
			}

			Timer()
			{
				//increases the timer variable
				this.m_timer++;

				//checks to see if the timer has reached its limit and sets the bomb to exploded if it has.
				if(this.m_timer >= this.m_maxTime)
				{
					this.m_explode = true;
				}
			}

			drawBomb()
			{
				//draws the object based on its position values and width and height values.
				ctx.drawImage(imgBomb, this.m_xpos, this.m_ypos, this.m_width, this.m_height);
            }
        }

        class Explosion extends TimedObject
        {
            constructor(xpos, ypos, width, height, timer, maxTimer, xFrames, yFrames, maxFrame)
			{
				super(xpos, ypos, width, height, timer, maxTimer)

				this.m_startTime = 0;
				this.m_frameX = 0;
				this.m_frameXMax = xFrames;
				this.m_frameY = 0;
				this.m_frameYMax = yFrames;
				this.m_frame = 0;
				this.m_frameMax = maxFrame;

				this.m_frameTimer = timer;
				this.m_frameTimeMax = maxTimer;

				this.m_spriteWidth = 128;
				this.m_spriteHeight = 128;
            }

            Timer()
            {
				//this variable creates an up to date timer in milliseconds that is used to alter the time it takes to move the animation frame to the next frame.
                var m_elapsedTime = (Date.now() - this.m_startTime)/1000;
				this.m_startTime = Date.now();

				//only update frames when timer is below 0
				this.m_frameTimer = this.m_frameTimer - m_elapsedTime;
				if(this.m_frameTimer <= 0)
				{
					//sets the frame timer to the max timer value
					this.m_frameTimer = this.m_frameTimeMax;
						
						//moves the xframe to the next position on the sprite sheet
						this.m_frameX++;

						//checks to see if the xframe has reached the max number of xframes.  If this is true, the xframe is reset back to 0 and the Yframe is increased
						//this causes the animation rectangle to move to the next row and restart back at the left of the sprite sheet
						if(this.m_frameX >= this.m_frameXMax)
						{
                            this.m_frameX = 0;
                            this.m_frameY++;
						}
					
					//increases the number of frames that have passed.
					this.m_frame++;
					//checks if the frames has reached the maximum number
					if(this.m_frame > this.m_frameMax)
					{
						//sets the explosion to being finished so it can be removed
						this.m_explode = true;
					}
				}
            }

            drawExplode()
			{
				//draws the explosion tile at the using the animation code in the timer method. This allows the specific part of the sprite sheet to be shown on the screen.
				ctx.drawImage(imgExplode, this.m_spriteWidth*this.m_frameX, this.m_spriteHeight*this.m_frameY, this.m_spriteWidth, this.m_spriteHeight, this.m_xpos, this.m_ypos, this.m_width, this.m_height);
			}
        }

		function bombManager(xpos, bomb, explode)
		{
			var m_bomb = bomb;
			var m_detonate = explode;

			//checks through every item in the bomb array
			for(var i = 0; i < m_bomb.length; i++)
			{
				//updates the bombs position and calls the bombs update function
				m_bomb[i].move(xpos);
				m_bomb[i].Timer();


				//checks to see if the currently selected bomb has been set to exploded
				if(m_bomb[i].m_explode)
				{
				//plays the bomb explosion audio, generates an explosion using the bombs position and uses the explosion array as a place to store the explosion objects and removes the bomb from the array.
					bombAudio.play();
					generateExplosion(m_bomb[i], explode);
					m_bomb.splice(i, 1);
					i--;
				}			
			}

			//checks through every item in the explosion array
			for(var i = 0; i < m_detonate.length; i++)
			{
				//updates the bombs position and calls the bombs update function
				m_detonate[i].move(xpos);
				m_detonate[i].Timer();

				//checks to see if the currently selected explosion has been set to exploded
				if(m_detonate[i].m_explode)
				{
					//removes the explosion tile from the array
					m_detonate.splice(i, 1);
					i--;
				}			
			}
		}

		function generateExplosion(bomb, list, audio)
		{
			var m_bomb = bomb;
			var m_explosions = list;

			var topcheck = false;
			var botcheck = false;
			var leftcheck = false;
			var rightcheck = false;

			//creates first explosion tile at bombs position
			m_explosions.push(new Explosion(m_bomb.m_xpos, m_bomb.m_ypos, 40, 40, 0.5, 0.1, 4, 4, 14));

			//loops set number of times to generate explosions
			for(var i = 0; i<2; i++)
			{
				//checks if the generator has hit an impassable tile before
				if(topcheck === false)
				{
					//variables to check which tile on the grid the bomb was on.
					var xcol = Math.round((m_bomb.m_xpos)/map.tileWidth);
					var ycol = Math.round((m_bomb.m_ypos - ((i+1)*40))/map.tileHeight);

					//gets the value of the tile from the maps array to find out the type of tile the bomb was on
					var tile = map.getTile(xcol, ycol);

					
					//if the value of tile was 1, an explosion is generated in this direction. If not then no more explosions will be generated in this direction
					switch(tile)
					{
					case 1:
						m_explosions.push(new Explosion(m_bomb.m_xpos, m_bomb.m_ypos  - ((i+1)*40), 40, 40, 0.5, 0.1, 4, 4, 14));
						break;
					default:
						topcheck = true;
						break;
					}
				}
				//same as above but different directions
				if(botcheck === false)
				{
					var xcol = Math.round((m_bomb.m_xpos)/map.tileWidth);
					var ycol = Math.round((m_bomb.m_ypos + ((i+1)*40))/map.tileHeight);

					var tile = map.getTile(xcol, ycol);

					switch(tile)
					{
					case 1:
						m_explosions.push(new Explosion(m_bomb.m_xpos, m_bomb.m_ypos  + ((i+1)*40), 40, 40, 0.5, 0.1, 4, 4, 14));
						break;
					default:
						botcheck = true;
						break;
					}
				}
				if (leftcheck === false)
				{
					var xcol = Math.round((m_bomb.m_xpos- ((i+1)*40))/map.tileWidth);
					var ycol = Math.round((m_bomb.m_ypos)/map.tileHeight);



					var tile = map.getTile(xcol, ycol);

					switch(tile)
					{
					case 1:
						m_explosions.push(new Explosion(m_bomb.m_xpos   - ((i+1)*40), m_bomb.m_ypos, 40, 40, 0.5, 0.1, 4, 4, 14));
						break;
					default:
						leftcheck = true;
						break;
					}
				}
				if (rightcheck === false)
				{
					var xcol = Math.round((m_bomb.m_xpos + ((i+1)*40))/map.tileWidth);
					var ycol = Math.round((m_bomb.m_ypos)/map.tileHeight);

					var tile = map.getTile(xcol, ycol);

					switch(tile)
					{
					case 1:
						m_explosions.push(new Explosion(m_bomb.m_xpos + ((i+1)*40), m_bomb.m_ypos, 40, 40, 0.5, 0.1, 4, 4, 14));
						break;
					default:
						rightcheck = true;
						break;
					}
				}
			}
		}

		function generateObstales(xpos, list)
		{
			var m_xpos = xpos;
			
			//loops 14 times to generate obstacles.
			for(var j = 0; j<14; j++)
			{
				//loops through each tile within the currently selected column on the map
				for(var i = 0; i<(map.mapHeight-2); i++)
				{
					//random number between 1 and 100
					var rng = Math.floor((Math.random() * 100) + 1);
					
					//checks to see if the random number is between these values. If they are a rock is generated
					if(rng >= 40 && rng < 88)
					{
						//checks the current tile in the column to determine if an object can be placed there or not
						var tile = map.getTile(m_xpos, i+1);
						switch(tile)
						{
							case 1:
								list.push(new Obstacle(m_xpos*40, (i+1)*40, 40, 40, 1))
								break;
							default:
								break;
						}
					}
					//checks to see if the random number is between these values. If they are a green gem is generated
					else if(rng >= 88 && rng < 94)
					{
						var tile = map.getTile(m_xpos, i+1);
						switch(tile)
						{
							case 1:
								list.push(new Obstacle(m_xpos*40, (i+1)*40, 40, 40, 2))
								break;
							default:
								break;
						}
					}
					//checks to see if the random number is between these values. If they are a blue gem is generated
					else if(rng >= 94 && rng < 99)
					{
						var tile = map.getTile(m_xpos, i+1);
						switch(tile)
						{
							case 1:
								list.push(new Obstacle(m_xpos*40, (i+1)*40, 40, 40, 3))
								break;
							default:
								break;
						}
					}
					//checks to see if the random number is between these values. If they are a yellow gem is generated
					else if(rng >= 99)
					{
						var tile = map.getTile(m_xpos, i+1);
						switch(tile)
						{
							case 1:
								list.push(new Obstacle(m_xpos*40, (i+1)*40, 40, 40, 4))
								break;
							default:
								break;
						}
					}
				}
				m_xpos++
			}
		}

		//function for collision detection
		function checkCollision(obj1, obj2)
		{
			var object1 = obj1;
			var object2 = obj2;

			//checcks to see if the two objects are colliding with eachother by using their x and y positions, as well as their width and height.
			//if the objects are colliding this function returns as true, otherwise it returns false.
			if((object1.m_xpos < object2.m_xpos + object2.m_width) &&
				(object1.m_xpos + object1.m_width > object2.m_xpos) &&
				(object1.m_ypos < object2.m_ypos  + object2.m_height) &&
				(object1.m_ypos + object1.m_height > object2.m_ypos))
				{
					return true;
				}
				else
				{
					return false
				}
		}
		//map variables
		var map = 
		{
			mapWidth: 27,
			mapHeight: 11,
			tileWidth: 40,
			tileHeight: 40,
			tileMap: [
			0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
			1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,
			1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
			1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,
			1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
			1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,
			1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
			1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,
			1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
			0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
			],

			//function that returns the value in the tilemap array based on the x and y coordinates put in
			getTile: function(x, y)
			{
				return this.tileMap[y * this.mapWidth + x]
			},
		};

		class lavaWall extends TimedObject
		{
			constructor(xpos, ypos, width, height, timer, maxTimer)
			{	
				super(xpos, ypos, width, height, timer, maxTimer)
			}

			//this method moves the wall based on the players x position and periodically through the use of a timer
			moveWal(xpos)
			{
				//increases the timer variable
				this.m_timer++;

				//checks to see if the timer has reached its max
				if(this.m_timer >= this.m_maxTime)
				{
					//moves the lava wall one tile and resets the timer. The lava audio is also playes
					this.m_xpos += map.tileWidth;
					this.m_timer = 0;
					lavaAudio.play();
				}

				//updates the walls position based on the input x position
				this.m_xpos -= xpos;
			}

			//this function resets the lava wall to its start position and sets the timer to 0
			reset()
			{
				this.m_xpos = -width+40;
				this.m_ypos = map.tileHeight;
				this.m_width = width;
				this.m_height = height - 80;

				this.m_timer = 0;
			}

			drawWall()
			{
				ctx.drawImage(imgLava, this.m_xpos, this.m_ypos, this.m_width, this.m_height);
			}
		}

		var lava = new lavaWall(-width+40, map.tileHeight, width, height-80, 0, 300);

		var isKeyPressed = false;

		class Player extends StaticImage
		{
			constructor (xpos, ypos, width, height, speed, xFrames, yFrames, maxFrame)
			{
				super(xpos, ypos, width, height)

				this.m_VelX = 0;
				this.m_VelY = 0;

				this.m_speed = speed;
		
				this.m_startTime = 0;
				this.m_frameX = 0;
				this.m_frameXMax = xFrames;
				this.m_frameY = 0;
				this.m_frameYMax = yFrames;
				this.m_frame = 0;
				this.m_frameMax = maxFrame;

				this.m_frameTimer = 0.05;
				this.m_frameTimeMax = 0.1;
				
				//the size of the image rectangle on the sprite sheet (i think)
				this.m_spriteWidth = 24;
				this.m_spriteHeight = 32;

				this.m_ismoving = false;

				this.bombDropped = false;
				this.playerCol = 
				{
					m_xpos: this.m_xpos +(6*40),
					m_ypos: this.m_ypos - 40,
					m_width: 10,
					m_height: 10,
				};
			}

			updatePlayer()
			{

				//Map looping
				//Checks to see if the x position is less than 0
				if(this.m_xpos < 0)
				{
					//sets the x position to 560 and reset the x velocity
					this.m_xpos = 560;
					this.velX = 0;
				}
				//Checks to see if the x position is greater than 560

				else if(this.m_xpos > 560)
				{
					//sets the x position to 0 and reset the x velocity
					this.m_xpos = 0;
					this.velX = 0;
					//generates a new set of obstacles
					generateObstales(13, obstacles);
				}

				//map collision variables for checking the current tile
				var xcol = Math.floor((this.m_xpos)/map.tileWidth);
				var ycol = Math.floor((this.m_ypos)/map.tileHeight);

				//Bomb dropping via the spacebar with a boolean variable to check if the button has been let go of
				if (keys[32] && this.bombDropped === false) 
				{
					//sets bomb dropped to true and changes the xcol and ycol variables to determine what tile the player is on
					this.bombDropped = true;
					xcol = Math.floor((this.m_xpos+(this.m_width/2))/map.tileWidth);
					ycol = Math.floor((this.m_ypos+(this.m_height/2))/map.tileHeight);

					//places a bomb using the xcol and ycol variables multiplied by the maps tile width in order to position them on the tile instead of where the player actually was
					bombs.push(new TimedObject((xcol*40-this.m_xpos)+(6*40), ycol*40, 40, 40, 0, 240));			
				}
				//checks to see if the spacebar has been let go
				else if(keys[32] === false && this.bombDropped)
				{
					this.bombDropped = false
				}

				//checks if the down key has been pressed
				if (keys[40]) 
				{
					//sets the player to being moving for animation. Sets the yframe to 0 to show the first row on the player sprite sheet.
					this.m_ismoving = true;
					this.m_frameY = 0;

					//colcheck variable to show if player has collided with something
					var colCheck = false;
					//collision variables used to track players tile collision
					xcol = Math.floor((this.m_xpos+(this.m_width/2))/map.tileWidth);
					ycol = Math.floor((this.m_ypos+(this.m_height))/map.tileHeight);

					//sets the diretion variable to the direction the player is moving and calls the update col method to alter the player col variable
					var direction = "down";
					this.updateCol(xcol, ycol, direction);

					//loops through each of the obstacles and checks if the player has collided with any of them
					for(var i = 0; i<obstacles.length; i++)
					{
						if(checkCollision(this.playerCol, obstacles[i]))
						{
							colCheck = true;
						}
					}

					//if the player has not collided with any obstacles, this statement is run
					if(!colCheck)
					{			
						//checks to see which tile the player is walking into
						var tile = map.getTile(xcol,ycol);
						
						//moves the player down if the player has not collided with a wall
						switch(tile)
						{
							case 1:
								this.m_VelY++;
								break;
							default:
								break;
						}
					}					
				}
				//same code as above but different direction
				else if (keys[38]) 
				{
					this.m_ismoving = true;
					this.m_frameY = 1;

					var colCheck = false;
					xcol = Math.floor((this.m_xpos+(this.m_width/2))/map.tileWidth);
					ycol = Math.floor((this.m_ypos)/map.tileHeight);

					var direction = "up";
					this.updateCol(xcol, ycol, direction);

					for(var i = 0; i<obstacles.length; i++)
					{
						if(checkCollision(this.playerCol, obstacles[i]))
						{
							colCheck = true;
						}
					}

					if(!colCheck)
					{
						// top arrow
					

						var tile = map.getTile(xcol,ycol);
						//console.log(tile);

						switch(tile)
						{
							case 1:
								this.m_VelY--;
								break;
							default:
								break;
						}
					}
				}
				//same code as above but different direction
				else if (keys[39]) 
				{
					this.m_ismoving = true;
					this.m_frameY = 3;
					var colCheck = false;
					xcol = Math.floor(((this.m_xpos+(this.m_width))/map.tileWidth));
					ycol = Math.floor((this.m_ypos+(this.m_height/2))/map.tileHeight);

					var direction = "right";
					this.updateCol(xcol, ycol, direction);

					for(var i = 0; i<obstacles.length; i++)
					{
						if(checkCollision(this.playerCol, obstacles[i]))
						{
							colCheck = true;
						}
					}

					if(!colCheck)
					{
						//right arrow
					

						if(xcol < 0)
							xcol = 0;

						var tile = map.getTile(xcol,ycol);
						//console.log(tile);

						switch(tile)
						{
							case 1:
								this.m_VelX++;
								break;
							default:
								break;
						}
					}
				}
				//same code as above but different direction
				else if (keys[37]) 
				{
					this.m_ismoving = true;
					this.m_frameY = 2;
					var colCheck = false;
					xcol = Math.floor(((this.m_xpos)/map.tileWidth));
					ycol = Math.floor((this.m_ypos+(this.m_height/2))/map.tileHeight);

					var direction = "left";
					this.updateCol(xcol, ycol, direction);

					for(var i = 0; i<obstacles.length; i++)
					{
						if(checkCollision(this.playerCol, obstacles[i]))
						{
							colCheck = true;
						}
					}

					if(!colCheck)
					{
						//left arrow
						xcol = Math.floor(((this.m_xpos)/map.tileWidth));
						ycol = Math.floor((this.m_ypos+(this.m_height/2))/map.tileHeight);
						//console.log(xcol);

						if(xcol < 0)
							xcol = 0;

						var tile = map.getTile(xcol,ycol);
						//console.log(tile);

						switch(tile)
						{
							case 1:
								this.m_VelX--;
								break;
							default:
								break;
						}
					}
				}
				else
				{
					this.m_ismoving = false;
				}
				
				//multiplies the x and y velocities by the speed value and updates the x and y positions with these velocities
				this.m_VelX *= this.m_speed;
				this.m_VelY *= this.m_speed;
				this.m_xpos += this.m_VelX;
				this.m_ypos += this.m_VelY;
			}

			//this method updates the players collision variable to be infront of them no matter which direction they are moving
			updateCol(colx, coly, direction)
			{
				//variables to store the input values
				var xcol = colx;
				var ycol = coly;
				var dir = direction;

				//checks if the player is moving up and places the collision rectangle above the player
				if(dir === "up")
				{
					this.playerCol.m_xpos = xcol + (6*40);
					this.playerCol.m_ypos = ycol*40;
				}
				//checks if the player is moving down and places the collision rectangle below the player
				if(dir === "down")
				{
					this.playerCol.m_xpos = xcol + (6*40);
					this.playerCol.m_ypos = ycol*40;
				}
				//checks if the player is moving left and places the collision rectangle to the left of the player
				if(dir === "left")
				{
					this.playerCol.m_xpos = (xcol + (6*40))-15;
					this.playerCol.m_ypos = ycol*40;
				}
				//checks if the player is moving right and places the collision rectangle to the right of the player
				if(dir === "right")
				{
					this.playerCol.m_xpos = (xcol + (6*40))+10;
					this.playerCol.m_ypos = ycol*40;
				}
			}

			//resets the player values to their original values
			reset()
			{
				this.m_xpos = 0;
				this.m_ypos = map.tileHeight*5;

				this.velX = 0;
				this.velY = 0;
			}

			drawPlayer()
			{
				var m_elapsedTime = (Date.now() - this.m_startTime)/1000;
				this.m_startTime = Date.now();

				//checks to see if the player is moving and animates the player if true
				if(this.m_ismoving)
				{
					//same animation code as used in the explosion class except the y frame is determined by the direction the player is moving
					this.m_frameTimer = this.m_frameTimer - m_elapsedTime;
					if(this.m_frameTimer <= 0)
					{
						this.m_frameTimer = this.m_frameTimeMax;

							this.m_frameX++;

							if(this.m_frameX >= this.m_frameXMax)
							{
								this.m_frameX = 0;
							}
						
						this.m_frame++;
						//reset frames to 0 in event that there are empty spaces on sprite sheet
						if(this.m_frame > this.m_frameMax)
						{
						  this.m_frame = 0;
						  this.m_frameX = 0;
						}
					}
				}
				//if the player is not moving, resets the x animation frames to 0 to make the placer look like they are standing still
				else
				{
					this.m_frame = 0;
					this.m_frameX = 0;
					this.m_frameTimer = this.m_frameTimeMax;
				}

				ctx.drawImage(playerSprite, this.m_spriteWidth*this.m_frameX, this.m_spriteHeight*this.m_frameY, this.m_spriteWidth, this.m_spriteHeight, (width/2) - (this.m_width/2), this.m_ypos, this.m_width, this.m_height);
			}
		}

		var player = new Player(0, map.tileHeight*5, 30, 30, 0.65, 8, 4, 8);

		function Reset()
		{
			//sets score to 0
			score = 0;
			
			//disables all HTML menu objects and enables the game canvas
			playBtn.style.display = "none";
			tutBtn.style.display = "none";
			exitBtn.style.display = "none";

			canvas.style.display = "initial";
			backgroundImg.style.display = "none";

			scoreDisplay.style.display = "none";
			playAgainBtn.style.display = "none";
			returnToMnBtn.style.display = "none";

			gameState = "Game";
			//empties bomb, explosion and obstacle arrays
			for(var i = 0; i< bombs.length; i++)
			{
				bombs.splice(i,1);
				i--;
			}
			for(var i = 0; i<explosion.length; i++)
			{
				explosion.splice(i,1);
				i--;
			}
			for(var i = 0; i<obstacles.length; i++)
			{
				obstacles.splice(i,1);
				i--;
			}

			//resets the player and lava wall
			player.reset();
			lava.reset();

			//updates the music and sets it to play and loop.
			music.src = "GameMusic.mp3";
			music.play();
			music.loop = "true";

			//generates new obstacles
			generateObstales(13, obstacles);
        }

        function Tutorial()
        {
			//sets tutpage to 0 so the first page is displayed
            tutpage = 0;

			//changed the gamestate to tutorial
            gameState = "Tutorial";

			//disables main menu assets
            playBtn.style.display = "none";
			tutBtn.style.display = "none";
            exitBtn.style.display = "none";

			//enables tutorial assets
            previousbtn.style.display = "initial";
            nextbtn.style.display = "initial";
            tutMainbtn.style.display = "initial";
        }
		
		//increases value of tutpage and resets it to 0 if it is higher than the number of tutorial pages
        function NextTut()
        {
            tutpage++;

            if (tutpage > 2)
            {
                tutpage = 0;
            }
        }

		//decreases value of tutpage and resets it to the number of tutorial pages  if it is lower than 0
        function PrevTut()
        {
            tutpage--;

            if (tutpage < 0)
            {
                tutpage = 2;
            }
        }

		function ReturnMain()
		{
		//changes the gamestate to main menu
			gameState = "Main";

			//changes the background image
			backgroundImg.style.display = "initial";
			backgroundImg.src = mainMenuImg.src;

			//disables game over assets
			scoreDisplay.style.display = "none";
			playAgainBtn.style.display = "none";
            returnToMnBtn.style.display = "none";

			//disables tutorial assets
            previousbtn.style.display = "none";
            nextbtn.style.display = "none";
            tutMainbtn.style.display = "none";

			//activates main menu assets
			playBtn.style.display = "initial";
			tutBtn.style.display = "initial";
			exitBtn.style.display = "initial";

			//changes the music to the main menu music
			music.src = "MenuMusic.wav";
			music.play();
			music.loop = "true";
		}

		function GameOver()
		{
			gameState = "GameOver";

			canvas.style.display = "none";

			backgroundImg.style.display = "initial";
			backgroundImg.src = gameOverImg.src;

			document.getElementById("score").innerHTML = "Score - " + score;

			if(score > highscore)
			{
				localStorage.setItem(highscore, score);
				highscore = localStorage.getItem(highscore);
			}

			if(highscore != null)
			document.getElementById("highscore").innerHTML = "Highscore - " + highscore;
			else
			document.getElementById("highscore").innerHTML = "Highscore - 0";

			scoreDisplay.style.display = "initial";
			playAgainBtn.style.display = "initial";
			returnToMnBtn.style.display = "initial";
		}

		function startMusic()
		{
			music.play();
			music.loop = "true";
		}

		//creates new function on load that runs when the page is first loaded
		window.addEventListener("load", function () 
		{
			start();
			update();
		});

		function start()
		{
			canvas.width = width;
			canvas.height = height;

			canvas.style.display = "none";
			
			mainMenuImg.src = "MenuBackground.png";
            gameOverImg.src = "GameOverBackground.png";

            controlImg.src = "TutControls.png";
            HowtoplayImg1.src = "TutHow1.png";
            HowtoplayImg2.src = "TutHow2.png";
            

			backgroundImg.src = mainMenuImg.src;

			playerSprite.src = 'Player.png';
			imgBomb.src = 'Bomb.png';
			imgExplode.src = 'Explosion.png';
			
			
			imgWall.src = 'Wall.png';
			imgPath.src = 'Dirt.png';
			imgRock.src = 'Rock.png';
			imgGem.src = 'Gem.png';
            imgGem2.src = 'Gem2.png';
            imgGem2break.src = "Gem2break.png";
            imgGem3.src = 'Gem3.png';
            imgGem3break.src = "Gem3break.png";

			imgLava.src = 'Lava.png';
			highscore = localStorage.getItem(highscore);

			startMusic();
		}
		
		//this function is run on every window update on the browser
		function update() 
		{
			//these if statements check which gamestate the game is currently in and updates the necessary functions based on this
			//this helps keep the framerate more stable.
			if(gameState === "Main")
			{

            }
            else if(gameState === "Tutorial")
            {
				//changes the background image that is being displayed by using the tutpage value
                if (tutpage === 0)
                {
                    backgroundImg.src = controlImg.src;
                }
                else if (tutpage === 1)
                {
                    backgroundImg.src = HowtoplayImg1.src;
                }
                else if (tutpage === 2)
                {
                    backgroundImg.src = HowtoplayImg2.src;
                }
			}
			else if(gameState === "Game")
			{
				
				//loops through each explosion
				for(var i = 0; i<explosion.length; i++)
				{
					//checks to see if the player character collides with any of the explosions. Runs the gameover function is this returns true
					if(checkCollision(player.playerCol, explosion[i]))
					{
						GameOver();
					}

					//loops through all the bombs
					for(var j = 0; j<bombs.length; j++)
					{
						//checks to see if any of the bombs collides with an explosion. If they do that bomb is also detonated.
						if(checkCollision(bombs[j], explosion[i]))
						{
							bombs[j].m_explode = true;
						}
					}
				}

				//if the player collides with the lava the gameover function is run
				if(checkCollision(player.playerCol, lava))
				{
					GameOver();
				}

				//calls the bomb manager function
				bombManager(player.m_VelX, bombs, explosion);

				//loops through each obstacle
				for(var i = 0; i<obstacles.length; i++)
				{
					//checks to see if the obstacle has been hit by an explosion by calling the checkExplosive method
					obstacles[i].checkExplosive(explosion);

					//checks if the obstacles durability has reached 0
					if(obstacles[i].m_durability <= 0)
					{
						//insreases the players score by the score of the obstacle that was destroyed and removes that obstacle from the array.
						score += obstacles[i].m_points;
						obstacles.splice(i,1);
						i--;
					}
					//checks if the obstacle has collided with the lava and removes them if they have
					else if(checkCollision(obstacles[i], lava))
					{
						obstacles.splice(i,1);
						i--;
					}
					else
					{
						//updates the obstacles position
						obstacles[i].move(player.m_VelX);	
					}
				}
				
				//updates the player character
				player.updatePlayer();

				//clears all drawn images from the previosu update and removes them from the canvas
				ctx.clearRect(0, 0, width, height);
			
				//for loop to draw each tile
				for(var x = 0; x< map.mapWidth; x++)
				{
					for(var y = 0; y< map.mapHeight; y++)
					{
						//checks the value of the tile based on map width and height
						var tile = map.getTile(x,y);
						//draws a different image based on the tile
						switch(tile)
						{
							case 0:
								ctx.drawImage(imgWall, -(player.m_xpos) + (x*map.tileWidth), y*map.tileHeight, map.tileWidth, map.tileHeight);
								break;
							default:
								ctx.drawImage(imgPath, -(player.m_xpos) + (x*map.tileWidth), y*map.tileHeight, map.tileWidth, map.tileHeight);
								break;
						}
					}
				}
			
			

				//updates the lava walls position using the lava walls moveWal method
				lava.moveWal(player.m_VelX);
				//draws the lavawall
				lava.drawWall();

				//draw obstacles
			
				for(var i = 0; i<obstacles.length; i++)
				{
					obstacles[i].draw();
				}
			
				//draws the bombs
				for(var i = 0; i<bombs.length; i++)
				{
					bombs[i].drawBomb();
				}

				//draws the explosions
				for(var i = 0; i<explosion.length; i++)
				{
					explosion[i].drawExplode();
				}

				//draws the player character
				player.drawPlayer();

				//ctx.fillRect(player.playerCol.m_xpos, player.playerCol.m_ypos, player.playerCol.m_width, player.playerCol.m_height);

				//creates a font and displays the score at the bottom left of the screen
				ctx.font = "16px Comic Sans MS";
				ctx.fillStyle = "black";
				ctx.textAlign = "left";
				ctx.fillText("Score - " + score, 10, height-16);

				ctx.textAlign = "right";

				//checks if the highsore in the local storage exists or not. Displays temporary value if it doesnt
				if(highscore == null)
				{
					ctx.fillText("Highscore - 0", width - 10, height-16);
				}
				else
				{
					//displays current highscore if it does exist
					ctx.fillText("Highscore - " + highscore, width - 10, height-16);
				}
			}
			else if(gameState = "GameOver")
			{

			}

			//runs the update function again when the window is next updated
			requestAnimationFrame(update);
		}
		
		//checks to see if a key has been pressed and sets these values accordingly depending on which key it was
		document.body.addEventListener("keydown", function (e) 
		{
			keys[e.keyCode] = true;
			isKeyPressed = true;
		});

		//checks to see if a key has been let go and updates these values based on that.
		document.body.addEventListener("keyup", function (e) 
		{
			keys[e.keyCode] = false;
			isKeyPressed = false;
		});


	</script>
	
</body>
</html>
